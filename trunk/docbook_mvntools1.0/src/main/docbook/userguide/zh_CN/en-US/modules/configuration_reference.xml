<chapter id="configuration_reference_chapter">
   <title>参考配置</title>
   <section id="sample_xml_file">
      <title>XML 配置文件例子</title>
      <para>
         这是典型 XML 配置文件的样子。推荐你使用 JBoss Cache 发布程序带有的配置文件，
         然后根据自己的需求做些调整，而不是从头写一个配置文件。
      </para>
      <programlisting role="XML"><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>


<!-- ===================================================================== -->
<!--                                                                       -->
<!--  Sample JBoss Cache Service Configuration                             -->
<!--                                                                       -->
<!-- ===================================================================== -->

<server>
   
   <!-- ==================================================================== -->
   <!-- Defines JBoss Cache configuration                                      -->
   <!-- ==================================================================== -->

   <!-- Note the value of the 'code' attribute has changed since JBC 1.x -->
   <mbean code="org.jboss.cache.jmx.CacheJmxWrapper" name="jboss.cache:service=Cache">
   
      <!-- Ensure JNDI and the TransactionManager are started before the
           cache.  Only works inside JBoss AS; ignored otherwise -->
      <depends>jboss:service=Naming</depends>
      <depends>jboss:service=TransactionManager</depends>

      <!-- Configure the TransactionManager -->
      <attribute name="TransactionManagerLookupClass">
         org.jboss.cache.transaction.GenericTransactionManagerLookup
      </attribute>

      <!-- Node locking level : SERIALIZABLE
                                REPEATABLE_READ (default)
                                READ_COMMITTED
                                READ_UNCOMMITTED
                                NONE             -->
      <attribute name="IsolationLevel">REPEATABLE_READ</attribute>

      <!-- Lock parent before doing node additions/removes -->
      <attribute name="LockParentForChildInsertRemove">true</attribute>

      <!-- Valid modes are LOCAL (default)
                           REPL_ASYNC
                           REPL_SYNC
                           INVALIDATION_ASYNC
                           INVALIDATION_SYNC   -->
      <attribute name="CacheMode">REPL_ASYNC</attribute>

      <!-- Name of cluster. Needs to be the same for all JBoss Cache nodes in a
           cluster in order to find each other. 
      -->
      <attribute name="ClusterName">JBossCache-Cluster</attribute>

      <!--Uncomment next three statements to use the JGroups multiplexer.
         This configuration is dependent on the JGroups multiplexer being
         registered in an MBean server such as JBossAS.  This type of
         dependency injection only works in the AS; outside it's up to
         your code to inject a ChannelFactory if you want to use one. 
      -->
      <!--
      <depends optional-attribute-name="MultiplexerService" 
      		proxy-type="attribute">jgroups.mux:name=Multiplexer</depends>
      <attribute name="MultiplexerStack">tcp</attribute>
      -->

      <!-- JGroups protocol stack properties.
         ClusterConfig isn't used if the multiplexer is enabled above.
      -->
      <attribute name="ClusterConfig">
         <config>
            <!-- UDP: if you have a multihomed machine, set the bind_addr 
                 attribute to the appropriate NIC IP address -->
            <!-- UDP: On Windows machines, because of the media sense feature
                 being broken with multicast (even after disabling media sense)
                 set the loopback attribute to true -->
            <UDP mcast_addr="228.1.2.3" mcast_port="48866"
                 ip_ttl="64" ip_mcast="true"
                 mcast_send_buf_size="150000" mcast_recv_buf_size="80000"
                 ucast_send_buf_size="150000" ucast_recv_buf_size="80000"
                 loopback="false"/>
            <PING timeout="2000" num_initial_members="3"/>
            <MERGE2 min_interval="10000" max_interval="20000"/>
            <FD shun="true"/>
            <FD_SOCK/>
            <VERIFY_SUSPECT timeout="1500"/>
            <pbcast.NAKACK gc_lag="50" retransmit_timeout="600,1200,2400,4800" />
            <UNICAST timeout="600,1200,2400",4800/>
            <pbcast.STABLE desired_avg_gossip="400000"/>
            <FC max_credits="2000000" min_threshold="0.10"/>
            <FRAG2 frag_size="8192"/>
            <pbcast.GMS join_timeout="5000" shun="true" print_local_addr="true"/>
            <pbcast.STATE_TRANSFER/>
         </config>
      </attribute>
      
      <!--
          The max amount of time (in milliseconds) we wait until the
          initial state (ie. the contents of the cache) are retrieved from
          existing members in a clustered environment
      -->
      <attribute name="StateRetrievalTimeout">20000</attribute>

      <!--
          Number of milliseconds to wait until all responses for a
          synchronous call have been received.
      -->
      <attribute name="SyncReplTimeout">20000</attribute>

      <!-- Max number of milliseconds to wait for a lock acquisition -->
      <attribute name="LockAcquisitionTimeout">15000</attribute>

      <!-- Shutdown hook behavior.  Valid choices are: DEFAULT, REGISTER and DONT_REGISTER.
           If this element is omitted, DEFAULT is used.  -->
      <attribute name="ShutdownHookBehavior">DEFAULT</attribute>

      <!-- Enables or disables lazy unmarshalling.  If omitted, the default is that lazy unmarshalling is enabled. -->
      <attribute name="UseLazyDeserialization">true</attribute>      

      <!-- Specific eviction policy configurations. This is LRU -->
      <attribute name="EvictionConfig">
         <config>
            <attribute name="wakeUpIntervalSeconds">5</attribute>
            <!-- This defaults to 200000 if not specified -->
            <attribute name="eventQueueSize">200000</attribute>
            <attribute name="policyClass">org.jboss.cache.eviction.LRUPolicy</attribute>

            <!-- Cache wide default -->
            <region name="/_default_">
               <attribute name="maxNodes">5000</attribute>
               <attribute name="timeToLiveSeconds">1000</attribute>
            </region>
            <region name="/org/jboss/data">
               <attribute name="maxNodes">5000</attribute>
               <attribute name="timeToLiveSeconds">1000</attribute>
            </region>
            <region name="/org/jboss/test/data">
               <attribute name="maxNodes">5</attribute>
               <attribute name="timeToLiveSeconds">4</attribute>
            </region>
            <region name="/test">
               <attribute name="maxNodes">10000</attribute>
               <attribute name="timeToLiveSeconds">4</attribute>
            </region>
            <region name="/maxAgeTest">
               <attribute name="maxNodes">10000</attribute>
               <attribute name="timeToLiveSeconds">8</attribute>
               <attribute name="maxAgeSeconds">10</attribute>
            </region>
         </config>
      </attribute>
   </mbean>
</server>
]]></programlisting>
   </section>


   <section id="configuration_reference">
      <title>XML 属性参考表</title>
      <para>这是上面使用的每个 XML 属性定义列表。如果属性状态描述是<emphasis>动态的</emphasis>，
      则意味着缓存创建和启动后也可以修改。
      </para>

      <informaltable frame="all">
         <tgroup cols="2">
            <tbody>
               <row>
                  <entry>
                     <para>名称</para>
                  </entry>

                  <entry>
                     <para>描述</para>
                  </entry>
               </row>
               <row>
                  <entry>
                     <para>BuddyReplicationConfig</para>
                  </entry>

                  <entry>
                     <para>一个包含详细伙伴复制配置的 XML 元素。
                     查看<link linkend="br">伙伴复制部分</link>，了解详细内容。
                     </para>
                  </entry>
               </row>

               <row>
                  <entry>
                     <para>CacheLoaderConfig</para>
                  </entry>

                  <entry>
                     <para>一个包含详细缓存加载器配置的 XML 元素。
                     查看<link linkend="cache_loaders">缓存加载器章节</link>，了解详细内容。
                     </para>
                  </entry>
               </row>

               <row>
                  <entry>
                     <para>CacheLoaderConfiguration</para>
                  </entry>

                  <entry>
                     <para>
                        <emphasis>不推荐使用</emphasis>。使用 <literal>CacheLoaderConfig</literal>。
                     </para>
                  </entry>
               </row>

               <row>
                  <entry>
                     <para>CacheMode</para>
                  </entry>

                  <entry>
                     <para>LOCAL, REPL_SYNC, REPL_ASYNC, INVALIDATION_SYNC 或 INVALIDATION_ASYNC。
                     缺省是 LOCAL。查看<link linkend="clustering">集群章节</link>，了解详细信息。
                     </para>
                  </entry>
               </row>

               <row>
                  <entry>
                     <para>ClusterConfig</para>
                  </entry>

                  <entry>
                     <para>配置底层 JGroups 堆栈。如果使用 <literal>MultiplexerService</literal>
                        和 <literal>MultiplexerStack</literal>，则忽略。
                        查看发布的源代码
                        <literal>resources/config-samples</literal> 目录下的各种 *-service.xml 样本文件。
                        查看 <ulink url="http://www.jgroups.org">JGroups 文档</ulink>
                        或者
                        <ulink url="http://wiki.jboss.org/wiki/Wiki.jsp?page=JGroups">JGroups wiki 页</ulink>，
                        了解更详细信息。
                     </para>
                  </entry>
               </row>

               <row>
                  <entry>
                     <para>ClusterName</para>
                  </entry>

                  <entry>
                     <para>集群名。为了节点之间相互通信，要求集群中所有节点的集群名都相同。
                     </para>
                  </entry>
               </row>
               <row>
                  <entry>
                     <para>EvictionPolicyConfig</para>
                  </entry>

                  <entry>
                     <para>指定驱逐策略的配置参数。
                        查看<link linkend="eviction_policies">驱逐策略章节</link>，
                        了解详细信息。这个属性是<emphasis>动态的</emphasis>。
                     </para>
                  </entry>
               </row>

               <row>
                  <entry>
                     <para>ExposeManagementStatistics</para>
                  </entry>

                  <entry>
                     <para>
                        指定提供统计数据的拦截器在启动时是否打开收集统计数据的开关。
                        也控制是否向拦截器链添加 <literal>CacheMgmtInterceptor</literal>
                        （它的唯一目的是收集统计数据）。缺省值是 <emphasis>true</emphasis>。
                        查看 <link linkend="jmx.statistics">JBoss Cache 统计数据部分</link>，
                        了解详细信息。
                     </para>
                  </entry>
               </row>

               <row>
                  <entry>
                     <para>FetchInMemoryState
                     </para>
                  </entry>

                  <entry>
                     <para>是否从已经存在的成员获得初始内存状态。
                     当打开这个开关时，允许热缓存。还要参考 <literal>CacheLoaderConfig</literal> 里的
                        <literal>fetchPersistentState</literal> 元素。
                        缺省值是 <literal>true</literal>。这个属性是<emphasis>动态的</emphasis>。
                     </para>
                  </entry>
               </row>

               <row>
                  <entry>
                     <para>InactiveOnStartup</para>
                  </entry>

                  <entry>
                     <para>在启动时，整个树是否是不活跃，只对调用
                        <literal>activateRegion()</literal> 激活树的一个或多个部分后反应复制信息。
                        如果是 true，忽略 <literal>FetchInMemoryState</literal> 属性。
                        只有在 <literal>UseRegionBasedMarshalling</literal> 也是 <literal>true</literal>的情况下，
                        这个属性才应该设置为 true。
                     </para>
                  </entry>
               </row>

               <row>
                  <entry>
                     <para>StateRetrievalTimeout</para>
                  </entry>

                  <entry>
                     <para>等待取回状态的时间，毫秒计。
                     这个时间应该比 <literal>LockAcquisitionTimeout</literal> 长，
                     因为提供状态的节点需要等待这么长的时间，以获得必要的缓存读锁。
                     这个属性是<emphasis>动态的</emphasis>。
                     </para>
                  </entry>
               </row>


               <row>
                  <entry>
                     <para>IsolationLevel</para>
                  </entry>

                  <entry>
                     <para>节点的加锁隔离层次：SERIALIZABLE, REPEATABLE_READ
                     （缺省的）, READ_COMMITTED, READ_UNCOMMITTED 和 NONE。
                     注意，如果 NodeLockingScheme 是 OPTIMISTIC，则忽略这个属性，不会造成什么麻烦。
                     查看有关事务和并发的文档，了解详细信息。
                     </para>
                  </entry>
               </row>

               <row>
                  <entry>
                     <para>LockAcquisitionTimeout</para>
                  </entry>

                  <entry>
                     <para>等待获得锁的时间，毫秒计。
                     如果不能获得一个锁，则抛出一个异常。这个属性是<emphasis>动态的</emphasis>。
                     </para>
                  </entry>
               </row>

               <row>
                  <entry>
                     <para>LockParentForChildInsertRemove</para>
                  </entry>

                  <entry>
                     <para>控制插入或移除一个节点时是否需要获得父节点的写锁（当使用悲观锁时），
                     或者是否导致父节点版本的更新（当使用乐观锁时）。缺省值是 <code>false</code>。
                     </para>
                  </entry>
               </row>

               <row>
                  <entry>
                     <para>MarshallerClass</para>
                  </entry>

                  <entry>
                     <para>用一个 <literal>org.jboss.cache.marshall.Marshaller</literal> 实例串行化数据为字节流。
                     如果没有指定，缺省是 <literal>org.jboss.cache.marshall.VersionAwareMarshaller</literal>。
                     </para>
                  </entry>
               </row>

               <row>
                  <entry>
                     <para>MultiplexerService</para>
                  </entry>

                  <entry>
                     <para>定义 JGroups 多路器的 JMX 服务对象名。在 JBoss AS 5.0 中，
                     这个服务一般定义在 jgroups-multiplexer.sar 中。
                     这个 XML 属性只能由 JBoss AS MBean 部署服务来处理。
                     如果将它包含在一个文件里传递给 <literal>CacheFactory</literal>，创建缓存工厂将失败。
                     在 JBoss AS 中，应该使用“depends optional-attribute-name”的语法形式定义属性，
                     象上面显示的例子一样。在 AS 中，如果定义了这个属性，
                     将在 <literal>CacheJmxWrapper</literal> 中插入一个
                    <literal>org.jgroups.jmx.JChannelFactoryMBean</literal> 实例，
                    <literal>CacheJmxWrapper</literal> 用它获得多路 JGroups 通道。
                    通道的配置将与 <literal>MultiplexerStack</literal> 关联。
                    <literal>ClusterConfig</literal> 属性将被忽略。
                     </para>
                  </entry>
               </row>

               <row>
                  <entry>
                     <para>MultiplexerStack</para>
                  </entry>

                  <entry>
                     <para>用于缓存集群的 JGroups 堆栈名。
                     堆栈在上面讨论的外部 <literal>MultiplexerService</literal> 配置中定义。
                     在 JBoss AS 5 中，一般在 jgroups-multiplexer.sar/META-INF/multiplexer-stacks.xml 文件中完成。
                     缺省堆栈是 <literal>udp</literal>。这个属性与 <literal>MultiplexerService</literal> 联合使用。
                     </para>
                  </entry>
               </row>

               <row>
                  <entry>
                     <para>NodeLockingScheme</para>
                  </entry>

                  <entry>
                     <para>可以是 PESSIMISTIC （缺省）或 OPTIMISTIC。
                     </para>
                  </entry>
               </row>

               <row>
                  <entry>
                     <para>ReplicationVersion</para>
                  </entry>
                  <entry>
                     <para>让缓存以 JBoss Cache 给定版本使用的格式串行化集群数据流。
                     不同 JBoss Cache 版本使用不同的报文格式，
                     设定这个属性让缓存从一个较新版本用较早版本的格式串行化数据。
                     这允许缓存的不同版本互相操作。例如，一个 2.1.0 缓存能够将这个值设为“2.0.0”，
                     允许它与一个 2.0.0 缓存互操作。有效值是用点符号隔开的版本数字，
                     最后的名字也是用点符号隔开的，例如“2.0.0”或“2.0.0.GA”。
                     在 2.x 系列中，不支持 1.x 版本表达的值。
                     </para>
                  </entry>
               </row>

               <row>
                  <entry>
                     <para>ReplQueueInterval</para>
                  </entry>

                  <entry>
                     <para>元素从复制队列到被复制的时间，毫秒计。
                     只有在打开 <literal>UseReplQueue</literal> 时使用。
                     这个属性是<emphasis>动态的</emphasis>。
                     </para>
                  </entry>
               </row>

               <row>
                  <entry>
                     <para>ReplQueueMaxElements</para>
                  </entry>

                  <entry>
                     <para>直到弹出复制为止，复制队列的最大元素数。
                     只有在打开 <literal>UseReplQueue</literal>时使用。
                     这个属性是<emphasis>动态的</emphasis>。
                     </para>
                  </entry>
               </row>

               <row>
                  <entry>
                     <para>SyncCommitPhase</para>
                  </entry>

                  <entry>
                     <para>当使用 REPL_SYNC （对其他缓存模式不起作用）时，
                     用这个选项控制 2 阶段提交协议提交部分的动作。
                     缺省情况下设置为 <literal>false</literal>。
                     打开这个选项会有性能上的损失，特别是在大的集群里运行，
                     但是有利的一面是集群范围数据完整性的提高。
                     查看有关集群缓存的章节，了解这方面的详细信息。
                     这个属性是<emphasis>动态的</emphasis>。
                     </para>
                  </entry>
               </row>

               <row>
                  <entry>
                     <para>SyncReplTimeout</para>
                  </entry>

                  <entry>
                     <para>对于同步复制：等待集群里所有节点都确认收到复制的时间，毫秒计。
                     通常最好比 <literal>LockAcquisitionTimeout</literal> 大。
                     这个属性是 <emphasis>动态的</emphasis>。
                     </para>
                  </entry>
               </row>

               <row>
                  <entry>
                     <para>SyncRollbackPhase</para>
                  </entry>

                  <entry>
                     <para>当使用 REPL_SYNC（对于其他缓存模式不起作用）时，
                     这个选项用于控制 2 阶段提交协议回滚部分的行为。
                     缺省值设为 <literal>false</literal>。
                     打开这个选项会有性能上的损失，特别是在大的集群里运行，
                     但是有利的一面是集群范围数据完整性的提高。
                     查看有关集群缓存的章节，了解这方面的详细信息。
                     这个属性是<emphasis>动态的</emphasis>。
                     </para>
                  </entry>
               </row>

               <row>
                  <entry>
                     <para>TransactionManagerLookupClass</para>
                  </entry>

                  <entry>
                     <para>实现 TransactionManagerLookup 的类的全限定名。
                     缺省是 JBossTransactionManagerLookup。
                     例如，还有一个 GenericTransactionManagerLookup 选项。
                     </para>
                  </entry>
               </row>

               <row>
                  <entry>
                     <para>UseInterceptorMbeans</para>
                  </entry>

                  <entry>
                     <para>
                        <emphasis>不推荐使用。</emphasis>
                        使用 <literal>ExposeManagementStatistics</literal>。
                     </para>
                  </entry>
               </row>

               <row>
                  <entry>
                     <para>UseRegionBasedMarshalling</para>
                  </entry>

                  <entry>
                     <para>当解码复制数据时，这个选项指定对于不同缓存区域是否支持使用不同类加载器。
                     如果没有说明，缺省是 <literal>false</literal>。
                     </para>
                     <para>
                        DEPRECATED 这个选项在 JBoss Cache 3.x 里会消失。
                        查看替代的 <literal>UseLazyDeserialization</literal>。
                     </para>
                  </entry>
               </row>

               <row>
                  <entry>
                     <para>UseReplQueue</para>
                  </entry>

                  <entry>
                     <para>对于异步复制：是否使用复制队列。缺省是 <literal>false</literal>。
                     </para>
                  </entry>
               </row>

               <row>
                  <entry>
                     <para>ShutdownHookBehavior</para>
                  </entry>

                  <entry>
                     <para>一个可选参数，控制 JBoss Cache 是否注册一个 JVM 运行时的关闭钩子。
                     允许的值是 <literal>DEFAULT</literal>,<literal>REGISTER</literal>
                     和 <literal>DONT_REGISTER</literal>。
                     <literal>REGISTER</literal> 和 <literal>DONT_REGISTER</literal>
                     分别强制或禁止注册关闭钩子，
                     如果没有找到 MBean 服务器（不是缺省的 JDK）并且假定是在一个受管理的环境中运行，
                     <literal>DEFAULT</literal>将注册一个。
                     象期望的那样，如果没有说明，缺省是<literal>DEFAULT</literal>。
                     </para>
                  </entry>
               </row>

               <row>
                  <entry>
                     <para>UseLazyDeserialization</para>
                  </entry>

                  <entry>
                     <para>一个可选的参数，可以用于打开或关闭缓存对象迟反串行化的使用。
                     缺省是 <literal>false</literal>，这要增加一个小的开销处理。
                     如果关闭迟反串行化，在调用线程离开时，隐含支持使用注册的环境类加载器。
                     </para>
                  </entry>
               </row>

               <row>
                  <entry>
                     <para>ObjectInputStreamPoolSize 和 ObjectOutputStreamPoolSize</para>
                  </entry>

                  <entry>
                     <para>
                        自从 JBoss Cache 2.1.0 开始，集群中用于串行化和反串行化 RPC 调用的对象输入和输出流，
                        都被集中起来，减少构造这些流的开销。通过使用特殊的可重放流实现来重用他们。
                     </para>
                     <para>
                        缺省情况下，这些流池每个设为 <literal>50</literal> 对象。
                        如果程序分析时你看到很多线程阻塞在
                        <literal>ObjectStreamPool.getInputStream()</literal>
                        或 <literal>ObjectStreamPool.getOutputStream()</literal>，
                        你可以增加或减少池的尺寸。
                        一般来说，拥有更多的流比少于所需更好。
                        基于你应用程序的情况，来保证你可用的流数量比你希望并发写缓存的线程数量多。
                     </para>
                  </entry>
               </row>

            </tbody>
         </tgroup>
      </informaltable>
   </section>
</chapter>